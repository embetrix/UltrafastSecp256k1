// ============================================================================
// shim_ecdsa.cpp — ECDSA sign/verify, signature parse/serialize
// ============================================================================
#include "secp256k1.h"

#include <cstring>
#include <array>

#include "secp256k1/scalar.hpp"
#include "secp256k1/point.hpp"
#include "secp256k1/field.hpp"
#include "secp256k1/ecdsa.hpp"

using namespace secp256k1::fast;

// ── Internal: opaque sig stores r (32 BE) || s (32 BE) ───────────────────
static void ecdsa_sig_to_data(const secp256k1::ECDSASignature& sig, unsigned char data[64]) {
    auto rb = sig.r.to_bytes();
    auto sb = sig.s.to_bytes();
    std::memcpy(data, rb.data(), 32);
    std::memcpy(data + 32, sb.data(), 32);
}

static secp256k1::ECDSASignature ecdsa_sig_from_data(const unsigned char data[64]) {
    std::array<uint8_t, 32> rb{}, sb{};
    std::memcpy(rb.data(), data, 32);
    std::memcpy(sb.data(), data + 32, 32);
    return { Scalar::from_bytes(rb), Scalar::from_bytes(sb) };
}

// ── Internal: reconstruct Point from opaque pubkey ──────────────────────
static Point pubkey_data_to_point(const unsigned char data[64]) {
    std::array<uint8_t, 32> xb{}, yb{};
    std::memcpy(xb.data(), data, 32);
    std::memcpy(yb.data(), data + 32, 32);
    auto x = FieldElement::from_bytes(xb);
    auto y = FieldElement::from_bytes(yb);
    return Point::from_affine(x, y);
}

extern "C" {

// ── Compact parse/serialize ──────────────────────────────────────────────

int secp256k1_ecdsa_signature_parse_compact(
    const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig,
    const unsigned char *input64)
{
    (void)ctx;
    if (!sig || !input64) return 0;
    std::memcpy(sig->data, input64, 64);
    return 1;
}

int secp256k1_ecdsa_signature_serialize_compact(
    const secp256k1_context *ctx, unsigned char *output64,
    const secp256k1_ecdsa_signature *sig)
{
    (void)ctx;
    if (!output64 || !sig) return 0;
    std::memcpy(output64, sig->data, 64);
    return 1;
}

// ── DER parse/serialize ──────────────────────────────────────────────────

static int parse_der_int(const unsigned char *&p, const unsigned char *end,
                         unsigned char out[32])
{
    if (p >= end || *p != 0x02) return 0;
    ++p;
    if (p >= end) return 0;
    size_t len = *p++;
    if (len == 0 || p + len > end) return 0;
    // Skip leading zeros
    while (len > 32 && *p == 0x00) { ++p; --len; }
    if (len > 32) return 0;
    std::memset(out, 0, 32);
    std::memcpy(out + (32 - len), p, len);
    p += len;
    return 1;
}

int secp256k1_ecdsa_signature_parse_der(
    const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig,
    const unsigned char *input, size_t inputlen)
{
    (void)ctx;
    if (!sig || !input || inputlen < 8) return 0;

    const unsigned char *p = input;
    const unsigned char *end = input + inputlen;

    if (*p++ != 0x30) return 0;
    size_t seqlen = *p++;
    if (seqlen > 70 || p + seqlen > end) return 0;

    unsigned char r[32]{}, s[32]{};
    if (!parse_der_int(p, end, r)) return 0;
    if (!parse_der_int(p, end, s)) return 0;

    std::memcpy(sig->data, r, 32);
    std::memcpy(sig->data + 32, s, 32);
    return 1;
}

static int der_encode_int(unsigned char *out, size_t *len, const unsigned char val[32]) {
    // Find first non-zero
    int start = 0;
    while (start < 32 && val[start] == 0) ++start;
    if (start == 32) start = 31; // encode zero as 0x00

    bool need_pad = (val[start] & 0x80) != 0;
    size_t int_len = 32 - start + (need_pad ? 1 : 0);

    out[0] = 0x02;
    out[1] = static_cast<unsigned char>(int_len);
    size_t pos = 2;
    if (need_pad) out[pos++] = 0x00;
    std::memcpy(out + pos, val + start, 32 - start);
    *len = 2 + int_len;
    return 1;
}

int secp256k1_ecdsa_signature_serialize_der(
    const secp256k1_context *ctx, unsigned char *output, size_t *outputlen,
    const secp256k1_ecdsa_signature *sig)
{
    (void)ctx;
    if (!output || !outputlen || !sig) return 0;

    unsigned char r_der[34]{}, s_der[34]{};
    size_t r_len = 0, s_len = 0;
    der_encode_int(r_der, &r_len, sig->data);
    der_encode_int(s_der, &s_len, sig->data + 32);

    size_t total = 2 + r_len + s_len;
    if (*outputlen < total) { *outputlen = total; return 0; }

    output[0] = 0x30;
    output[1] = static_cast<unsigned char>(r_len + s_len);
    std::memcpy(output + 2, r_der, r_len);
    std::memcpy(output + 2 + r_len, s_der, s_len);
    *outputlen = total;
    return 1;
}

// ── Normalize ────────────────────────────────────────────────────────────

int secp256k1_ecdsa_signature_normalize(
    const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout,
    const secp256k1_ecdsa_signature *sigin)
{
    (void)ctx;
    if (!sigin) return 0;

    try {
        auto sig = ecdsa_sig_from_data(sigin->data);
        bool was_high = !sig.is_low_s();
        auto norm = sig.normalize();
        if (sigout) ecdsa_sig_to_data(norm, sigout->data);
        return was_high ? 1 : 0;
    } catch (...) { return 0; }
}

// ── Verify ───────────────────────────────────────────────────────────────

int secp256k1_ecdsa_verify(
    const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig,
    const unsigned char *msghash32, const secp256k1_pubkey *pubkey)
{
    (void)ctx;
    if (!sig || !msghash32 || !pubkey) return 0;

    try {
        auto internal_sig = ecdsa_sig_from_data(sig->data);
        auto P = pubkey_data_to_point(pubkey->data);

        std::array<uint8_t, 32> msg{};
        std::memcpy(msg.data(), msghash32, 32);

        return secp256k1::ecdsa_verify(msg, P, internal_sig) ? 1 : 0;
    } catch (...) { return 0; }
}

// ── Sign ─────────────────────────────────────────────────────────────────

int secp256k1_ecdsa_sign(
    const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig,
    const unsigned char *msghash32, const unsigned char *seckey,
    secp256k1_nonce_function noncefp, const void *ndata)
{
    (void)ctx; (void)noncefp; (void)ndata;
    if (!sig || !msghash32 || !seckey) return 0;

    try {
        std::array<uint8_t, 32> msg{}, kb{};
        std::memcpy(msg.data(), msghash32, 32);
        std::memcpy(kb.data(), seckey, 32);
        auto k = Scalar::from_bytes(kb);
        if (k.is_zero()) return 0;

        auto result = secp256k1::ecdsa_sign(msg, k);
        if (result.r.is_zero() && result.s.is_zero()) return 0;
        ecdsa_sig_to_data(result, sig->data);
        return 1;
    } catch (...) { return 0; }
}

// ── RFC 6979 nonce function pointers (stubs — sign uses internal RFC 6979) ─

static int nonce_function_rfc6979_stub(unsigned char *, const unsigned char *,
    const unsigned char *, const unsigned char *, void *, unsigned int)
{ return 1; }

const secp256k1_nonce_function secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979_stub;
const secp256k1_nonce_function secp256k1_nonce_function_default = nonce_function_rfc6979_stub;

} // extern "C"
